# 🤖 QMIX 기반 4-Agent 주식 트레이딩 AI

삼성전자(005930.KS) 주식을 대상으로 **4개의 전문 AI 에이전트**가 협력하여 매매 결정을 내리는 멀티에이전트 강화학습 시스템입니다.

QMIX 알고리즘을 통해 각 에이전트의 전문성을 살리면서도, 팀 전체의 수익을 극대화하는 방향으로 학습합니다.

## ✨ 주요 특징

- **4개 전문 에이전트**: 단기/장기/위험/감성 분석을 각각 담당
- **투표 기반 의사결정**: 2표 이상 합의 시에만 거래 (신중한 판단)
- **신호 강도 반영**: 합의 정도에 따라 거래량 조절
- **XAI (설명 가능 AI)**: Gradient 기반으로 의사결정 근거 제시
- **백테스팅**: 1년간 실제 데이터로 성과 검증 (Sharpe, Sortino, MDD)

## 📂 프로젝트 구조

```
.
├── main.py             # 메인 실행 (학습 → 백테스팅 → 결과 시각화)
├── qmix_model.py       # QMIX 모델 (Q_Net, DQN_Agent, Mixer, QMIX_Learner)
├── environment.py      # 주식 거래 환경 (MARLStockEnv, Gymnasium 기반)
├── data_processor.py   # 데이터 수집 및 전처리 (yfinance, pandas-ta)
├── replay_buffer.py    # 경험 리플레이 버퍼
├── config.py           # 하이퍼파라미터 및 설정
└── requirements.txt    # 필수 패키지 목록
```
## 🤖 4개 전문 에이전트 구성

각 에이전트는 **서로 다른 관찰값(Observation)**을 받아 전문 분야에 집중합니다.

### 🔹 Agent 0: 단기 트레이더 (Short-term Trader)
**역할**: 단기 모멘텀 및 과매수/과매도 신호 포착

**관찰 지표 (13개)**:
- 가격: `Close`, `High`, `Low`, `Volume`
- 기술적: `RSI`, `Stoch_K`, `Stoch_D`, `ATR`, `Bollinger_B`

**특징**: VIX를 제외하여 단기 변동성에만 집중

---

### 🔹 Agent 1: 장기 투자자 (Long-term Investor)
**역할**: 추세 및 펀더멘탈 분석

**관찰 지표 (14개)**:
- 가격: `Close`, `High`, `Low`, `Volume`
- 추세: `SMA20`, `MACD`, `MACD_Signal`, `VIX`
- 펀더멘탈: `ROA`, `DebtRatio`, `AnalystRating`

**특징**: 재무제표와 애널리스트 의견 반영

---

### 🔹 Agent 2: 위험 관리자 (Risk Manager)
**역할**: 시장 위험 및 변동성 모니터링

**관찰 지표 (8개)**:
- 가격: `Close`, `High`, `Low`, `Volume`
- 위험: `VIX`, `ATR`, `Bollinger_B`

**특징**: 최소한의 지표로 위험 신호에만 집중

---

### 🔹 Agent 3: 시장 감성 분석가 (Sentiment Analyst)
**역할**: 시장 심리 및 거래 패턴 분석

**관찰 지표 (11개)**:
- 가격: `Close`, `High`, `Low`, `Volume`
- 감성: `Volume_Ratio`, `Price_Momentum_5`, `Price_Momentum_20`
- 변동성: `Price_Volatility`, `Market_Strength`, `VIX_Change`, `Price_Acceleration`

**특징**: 거래량 급증, 모멘텀 전환, 공포 지수 변화 감지

---

## 🧠 QMIX 학습 메커니즘

```
1. 각 에이전트가 전문 지표를 보고 개별 Q-Value 계산
   Agent 0: Q₀(obs₀, a₀)  →  [Long: 0.8, Hold: 0.3, Short: 0.1]
   Agent 1: Q₁(obs₁, a₁)  →  [Long: 0.6, Hold: 0.5, Short: 0.2]
   Agent 2: Q₂(obs₂, a₂)  →  [Long: 0.4, Hold: 0.7, Short: 0.3]
   Agent 3: Q₃(obs₃, a₃)  →  [Long: 0.9, Hold: 0.2, Short: 0.1]

2. QMIX Mixer가 글로벌 상태를 보고 팀 Q-Value 계산
   Q_total = Mixer([Q₀, Q₁, Q₂, Q₃], global_state)
   
3. 81가지 행동 조합(3⁴) 중 Q_total이 최대인 조합 선택
   예: (Long, Long, Hold, Long) → Q_total = 152.73

4. 투표 집계 후 최종 행동 결정
   Long 3표 + Hold 1표 = +3 → 총 자산의 7.5% 매수
```

**핵심**: 믹서가 "지금 상황에서는 Agent 3의 의견을 더 따르는 게 팀 수익에 좋다"는 식의 협력 전략을 학습합니다.

## 🚀 설치 및 실행

### 1. 환경 설정

```bash
# Conda 환경 생성 (권장)
conda create -n qmix python=3.12 -y
conda activate qmix

# 패키지 설치
pip install -r requirements.txt
```

### 2. 실행

**기본 실행 (초기 자본 1,000만원)**:
```bash
python main.py
```

**초기 자본 변경**:
```bash
python main.py --capital 50000000  # 5,000만원으로 시작
```

### 3. 실행 과정

```
1. 데이터 다운로드 (2014-2025, 약 11년)
   └─ 삼성전자 주가 + VIX 지수 + 재무제표 + 애널리스트 의견

2. 기술적 지표 계산 (총 30개 이상)
   └─ RSI, MACD, Bollinger Bands, 거래량 비율 등

3. 데이터 분할
   └─ 학습: 약 10년 (2014-2024)
   └─ 백테스팅: 1년 (2024-2025, 최근 252 거래일)

4. QMIX 학습 (500 에피소드, 약 5-10분 소요)
   └─ 4개 에이전트가 10년 데이터로 협력 전략 학습

5. 백테스팅 수행
   └─ 학습된 모델로 1년간 실제 거래 시뮬레이션

6. 결과 출력
   └─ 성과 지표 + 그래프 + 최종일 상세 분석
```

## 📊 투표 기반 의사결정 시스템

### 투표 메커니즘

**1단계: 각 에이전트 투표**
```python
Agent 0 → Long (Buy)   = +1
Agent 1 → Long (Buy)   = +1  
Agent 2 → Hold         =  0
Agent 3 → Long (Buy)   = +1
─────────────────────────────
투표 합산              = +3
```

**2단계: 행동 결정**
```
투표 합산 ≥ +2  →  매수 (2~4표 찬성)
투표 합산 ≤ -2  →  매도 (2~4표 찬성)
-1 ~ +1         →  관망 (의견 불일치)
```

**3단계: 거래량 계산**

**매수 시 (투표 ≥ +2)**:
```python
신호 강도 = 투표 합산 / 4
매수 비율 = 신호 강도 × 0.1  # 최대 10%
매수 금액 = 포트폴리오 가치 × 매수 비율

예시:
+2표 (2/4 = 0.5) → 총 자산의 5% 매수
+3표 (3/4 = 0.75) → 총 자산의 7.5% 매수
+4표 (4/4 = 1.0) → 총 자산의 10% 매수 (만장일치)
```

**매도 시 (투표 ≤ -2)**:
```python
신호 강도 = |투표 합산| / 4
매도 비율 = 신호 강도 × 0.3  # 최대 30%
매도 주식 수 = 보유 주식 × 매도 비율

예시:
-2표 (2/4 = 0.5) → 보유 주식의 15% 매도
-3표 (3/4 = 0.75) → 보유 주식의 22.5% 매도
-4표 (4/4 = 1.0) → 보유 주식의 30% 매도 (만장일치)
```

### 투표 시나리오 예시

| Agent 0 | Agent 1 | Agent 2 | Agent 3 | 합산 | 행동 | 거래량 |
|---------|---------|---------|---------|------|------|--------|
| Buy | Buy | Buy | Buy | +4 | 매수 | 총 자산 10% |
| Buy | Buy | Buy | Hold | +3 | 매수 | 총 자산 7.5% |
| Buy | Buy | Hold | Hold | +2 | 매수 | 총 자산 5% |
| Buy | Hold | Hold | Sell | 0 | **관망** | 거래 없음 |
| Sell | Sell | Hold | Hold | -2 | 매도 | 보유 주식 15% |
| Sell | Sell | Sell | Hold | -3 | 매도 | 보유 주식 22.5% |

### 장점

✅ **신중한 의사결정**: 2표 이상 합의 필요 (50% 이상 동의)  
✅ **리스크 관리**: 의견 불일치 시 관망으로 손실 방지  
✅ **확신도 반영**: 합의 정도에 따라 거래량 조절  
✅ **과도한 거래 방지**: 최대 매수 10%, 매도 30%로 제한


## 📈 출력 결과

### 1. 백테스팅 성과 지표

```
--- [2] 백테스트 성능 지표 (신뢰도/정확도) ---
    - 백테스트 기간    : 241 일
    - 초기 투자 금액   : 10,000,000 원
    - 최종 포트폴리오  : 17,278,700 원
    - 보유 주식        : 176 주
    - 보유 현금        : 171,500 원
    - 누적 수익(PnL)   : 7,278,700 원 (+72.79%)
    - 일 평균 수익     : 30,202 원
    - 일 수익 변동성   : 8.3802
    - 샤프 비율 (연환산): 1.399
    - 승률 (일별)      : 51.87% (125/241일)
```

**성과 지표 설명**:
- **Sharpe Ratio**: 위험 대비 수익률 (1.0 이상이면 양호)
- **Sortino Ratio**: 하방 위험만 고려한 수익률
- **MDD (Maximum Drawdown)**: 최대 낙폭 (낮을수록 안정적)
- **승률**: 일일 수익이 양수인 날의 비율

### 2. 백테스팅 그래프

`backtest_results.png` 파일로 저장됩니다.

**그래프 내용**:
- QMIX Agent 포트폴리오 가치 추이 (파란선)
- KOSPI Buy & Hold 벤치마크 (보라선)
- 초기 자본 기준선 (회색 점선)

### 3. 최종일 상세 분석 (XAI)

```
=============================================
      [ 📱 리브리 AI 분석 결과 (삼성전자) ]
=============================================

--- 1. AI 최종 신호 ---
    적극 매수
    (예상 팀 Q-Value: 152.7314)

--- 2. AI 설명 ---
AI가 '적극 매수'을 결정한 주된 이유는 다음과 같습니다.

  1. 'Volume_Ratio' 지표의 최근 움직임을 가장 중요하게 고려했습니다.
  2. 'Price_Momentum_5' 지표가 2순위로 결정에 영향을 미쳤습니다.
  3. 마지막으로 'RSI' 지표를 참고했습니다.

--- 3. 기술적 분석 상세 (최종일 기준) ---
    (AI가 입수하여 분석한 원본 데이터입니다.)

    - SMA20        : 75000.00
    - MACD         : 1234.56
    - MACD_Signal  : 1100.00
    - RSI          : 65.43
    - Stoch_K      : 70.12
    - Stoch_D      : 68.90
    - ATR          : 2500.00
    - Bollinger_B  : 0.75
    - VIX          : 15.30

    (펀더멘탈 및 기타 데이터)

    - ROA          : 0.08
    - DebtRatio    : 0.35
    - AnalystRating: 0.65
=============================================
```

**XAI (설명 가능 AI) 원리**:
1. 각 에이전트의 Q-Network에서 Gradient 계산
2. 입력 지표별 영향도(중요도) 추출
3. 4개 에이전트의 중요도를 합산
4. Top 3 지표를 사용자에게 제시

### 4. 포트폴리오 계산 방식

```python
포트폴리오 가치 = 현금 + (보유 주식 수 × 현재 가격)

일일 수익(PnL) = 오늘 포트폴리오 가치 - 어제 포트폴리오 가치

수익률 = (최종 포트폴리오 - 초기 자본) / 초기 자본 × 100
```

---

## ⚙️ 주요 설정 (config.py)

```python
# 데이터 설정
TICKER = "005930.KS"        # 삼성전자
VIX_TICKER = "^VIX"         # 공포 지수
START_DATE = "2014-11-17"   # 약 11년 데이터
END_DATE = "2025-11-18"     # (학습 10년 + 백테스팅 1년)

# 에이전트 설정
N_AGENTS = 4                # 4개 전문 에이전트
WINDOW_SIZE = 10            # 10일 시계열 윈도우

# 학습 설정
NUM_EPISODES = 500          # 학습 에피소드
BATCH_SIZE = 64
BUFFER_SIZE = 50000
LR = 5e-5                   # 학습률
GAMMA = 0.99                # 할인율

# QMIX 설정
MIXER_EMBED_DIM = 32        # 믹서 임베딩 차원
TARGET_UPDATE_FREQ = 200    # 타겟 네트워크 업데이트 주기
```

---

## 🔬 기술적 세부사항

### 보상 함수 (Reward Function)

```python
# 1. 수익률 계산
return_pct = (포트폴리오 변화) / 초기_자본

# 2. Sharpe 컴포넌트 (위험 조정 수익)
sharpe = return_pct / (최근_20일_변동성 + 1e-6)
sharpe = clip(sharpe, -3.0, 3.0)

# 3. 최종 보상 (수익 + 안정성)
reward = (return_pct × 1000) + (sharpe × 0.5)
reward = clip(reward, -10.0, 10.0)
```

**특징**:
- 수익률과 안정성을 동시에 고려
- 변동성이 낮으면서 수익이 높은 전략 선호
- 극단값 클리핑으로 학습 안정화

### 정규화 (Normalization)

| 지표 유형 | 정규화 방법 | 예시 |
|----------|------------|------|
| 가격 | 첫날 대비 변화율 | `(price / first_price) - 1` |
| 거래량 | MinMaxScaler | 0~1 범위 |
| 비율 지표 | 100으로 나누기 | RSI: 0~1 범위 |
| 변동성 | StandardScaler | 평균 0, 표준편차 1 |
| 볼린저 %B | 클리핑 | -1~2 범위 |

---

## 🛠️ 커스터마이징

### 다른 종목으로 변경

```python
# config.py
TICKER = "000660.KS"  # SK하이닉스
# 또는
TICKER = "035420.KS"  # NAVER
```

### 학습 에피소드 조정

```python
# config.py
NUM_EPISODES = 1000  # 더 긴 학습 (성능 향상 가능)
```

### 초기 자본 변경

```bash
python main.py --capital 100000000  # 1억원
```
